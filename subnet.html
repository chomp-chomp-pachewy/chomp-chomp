<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIDR & Subnet Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #ffffff;
            color: #434343;
            line-height: 1.6;
        }
    
        nav {
            padding: 20px;
            text-align: right;
        }

        nav a {
            color: #999;
            text-decoration: none;
            margin-left: 30px;
            font-size: 0.95em;
        }

        nav a:hover {
            color: #333;
        }

        .header {
            background-color: #ffffff;
            padding: 30px 20px 20px 20px;
            text-align: center;
        }
        
        .header img {
            max-width: 300px;
            height: auto;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
        }

        .section {
            margin-bottom: 60px;
        }
        
    .section-title {
      color: #fe0032;
      font-size: 1.15em;
      font-weight: 700;
      margin-bottom: 15px;
      text-transform: lowercase;
    }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 12px;
            font-weight: 400;
            color: #666666;
            font-size: 1em;
            text-transform: lowercase;
        }
        
        select, input[type="text"] {
            width: 100%;
            padding: 14px 16px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            transition: all 0.2s;
            text-transform: lowercase;
            height: 52px;
            box-sizing: border-box;
        }
       
        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #fe0032;
        }

        input[type="text"]::placeholder {
            color: #999;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .input-row-two {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 14px 30px;
            font-size: 15px;
            font-family: 'Roboto', sans-serif;
            border: 1px solid #434343;
            border-radius: 8px;
            background-color: #ffffff;
            color: #434343;
            cursor: pointer;
            transition: all 0.2s;
            height: 52px;
            text-transform: lowercase;
            font-weight: 400;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: #fe0032;
            border-color: #fe0032;
            color: #ffffff;
        }

        .results {
            margin-top: 40px;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .result-box {
            background-color: #F2F2F4;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-box-label {
            color: #666666;
            font-size: 0.85em;
            margin-bottom: 8px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-box-value {
            color: #000000;
            font-size: 1em;
            font-weight: 400;
            font-family: monospace;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: space-between;
        }

        .result-section {
            margin-bottom: 30px;
            background-color: #F2F2F4;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #434343;
        }

        .result-section h3 {
            color: #fe0032;
            font-size: 1em;
            margin-bottom: 20px;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #ddd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #666666;
            font-weight: 400;
            text-transform: lowercase;
        }

        .result-value {
            font-weight: 400;
            color: #000000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #666666;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            color: #fe0032;
        }

        .error {
            color: #fe0032;
            padding: 15px;
            background-color: #fff0f0;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.95em;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #434343;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(1rem);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-section {
            margin-top: 40px;
            padding: 30px;
            background-color: #F2F2F4;
            color: #000000;
            border-radius: 8px;
            border: 1px solid #434343;
            margin-bottom: 100px;
        }

        .info-section strong {
            color: #fe0032;
            font-weight: 400;
            display: block;
            margin-bottom: 10px;
            font-size: 1em;
            text-transform: lowercase;
        }

        .info-section p {
            margin: 0 0 15px 0;
            color: #000000;
            font-weight: 300;
            line-height: 1.8;
            font-size: 0.95em;
        }

        .info-section p:last-child {
            margin-bottom: 0;
        }

        .subnet-binary {
            font-family: monospace;
            font-size: 0.85em;
            color: #666666;
            margin-top: 0.25rem;
        }

        .divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 60px 0;
        }

        .clear-link {
            text-align: center;
            margin: 30px 0 20px 0;
        }

        .clear-link a {
            color: #fe0032;
            text-decoration: none;
            font-size: 0.95em;
            cursor: pointer;
            transition: opacity 0.2s;
            text-transform: lowercase;
        }

        .clear-link a:hover {
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .input-row {
                grid-template-columns: 1fr;
            }

            .input-row-two {
                grid-template-columns: 1fr;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="https://chomp.ltd">home</a>
        <a href="https://tools.chomp.ltd">tools</a>
    </nav>

    <div class="header">
        <img src="https://raw.githubusercontent.com/chomp-chomp-pachewy/chomp-chomp/refs/heads/main/subnet.png" alt="Subnet Calculator">
    </div>

    <div class="container">
        <!-- Subnet Calculator Section -->
        <div class="section">
            <div class="section-title">subnet calculator</div>
            
            <div class="form-group">
                <label for="ipAddress">ip address / cidr</label>
                <div class="input-row">
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.0/24 or 192.168.1.0">
                    <select id="subnetMask">
                        <option value="">select mask (optional)</option>
                        <option value="32">/32 - 255.255.255.255</option>
                        <option value="31">/31 - 255.255.255.254</option>
                        <option value="30">/30 - 255.255.255.252</option>
                        <option value="29">/29 - 255.255.255.248</option>
                        <option value="28">/28 - 255.255.255.240</option>
                        <option value="27">/27 - 255.255.255.224</option>
                        <option value="26">/26 - 255.255.255.192</option>
                        <option value="25">/25 - 255.255.255.128</option>
                        <option value="24">/24 - 255.255.255.0</option>
                        <option value="23">/23 - 255.255.254.0</option>
                        <option value="22">/22 - 255.255.252.0</option>
                        <option value="21">/21 - 255.255.248.0</option>
                        <option value="20">/20 - 255.255.240.0</option>
                        <option value="19">/19 - 255.255.224.0</option>
                        <option value="18">/18 - 255.255.192.0</option>
                        <option value="17">/17 - 255.255.128.0</option>
                        <option value="16">/16 - 255.255.0.0</option>
                        <option value="15">/15 - 255.254.0.0</option>
                        <option value="14">/14 - 255.252.0.0</option>
                        <option value="13">/13 - 255.248.0.0</option>
                        <option value="12">/12 - 255.240.0.0</option>
                        <option value="11">/11 - 255.224.0.0</option>
                        <option value="10">/10 - 255.192.0.0</option>
                        <option value="9">/9 - 255.128.0.0</option>
                        <option value="8">/8 - 255.0.0.0</option>
                    </select>
                    <button class="btn" onclick="calcSubnet()">calculate</button>
                </div>
            </div>

            <div id="subnetError" class="error" style="display: none;"></div>
            
            <div id="subnetResults" class="results" style="display: none;"></div>

<div class="input-row-two" id="copySubnetBtnContainer" style="display:none;">
  <button class="btn" id="copySubnetBtn" onclick="copyAllSubnetResults()">copy all results</button>
 <button class="btn" id="copySubnetBtn" onclick="downloadSubnetResults">download .txt</button>
</div>

            <div class="clear-link">
                <a onclick="clearSubnet()">clear all values</a>
            </div>
        </div>

        <div class="divider"></div>

<!-- CIDR Calculator -->
<section id="cidr-section" class="calc-section">
  <div class="section-title">CIDR Range Calculator</div>

  <div class="form-group">
    <label for="startIp">Start IP Address</label>
    <input type="text" id="startIp" placeholder="e.g., 192.168.0.0" />
  </div>

  <div class="form-group">
    <label for="endIp">End IP Address</label>
    <input type="text" id="endIp" placeholder="e.g., 192.168.0.255" /></div>

      <div><button class="btn" onclick="calcCIDR()">calculate</button></div>
      
  <!-- <div class="button-row">
    <button class="primary-btn" onclick="calcCIDR()">Calculate</button>
    <button class="clear-btn" onclick="clearCIDR()">Clear All Values</button>
  </div> -->

  <div id="cidrError" class="error-message" style="display:none;"></div>

  <div id="cidrResults" class="results-card" style="display:none;">
      <div id="cidrOutput">
  <div class="info-section" id="cidrInfoSection" style="display:none;">
    <strong>cidr results</strong>
    <p id="cidrInfoText"></p>
  </div>
</div>      
  </div>
 <div class="clear-link">
                <a onclick="clearCIDR()">clear all values</a>
            </div>
</section>

        <div class="info-section">
            <strong>about these calculators</strong>
            <p><strong>subnet calculator:</strong> takes a network address in CIDR notation (like 192.168.1.0/24) and calculates important network information including the network address, broadcast address, subnet mask, and the range of usable IP addresses. the prefix length determines how many IP addresses are in the subnet.</p>
            <p><strong>cidr calculator:</strong> converts IP address ranges to CIDR notation. CIDR (classless inter-domain routing) is a compact method for specifying IP address ranges. it consists of an IP address followed by a slash and a number (the prefix length), such as 192.168.1.0/24.</p>
        </div>
    </div>

    <div id="toast" class="toast"></div>


<script>
/* ---------------------------
   Utilities (IPv4 + IPv6)
   --------------------------- */

/* --- IPv4 helpers (kept same semantics) --- */
function ipToInt(ip) {
    const parts = ip.split('.').map(Number);
    return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];
}
function intToIp(int) {
    return [
        (int >>> 24) & 0xFF,
        (int >>> 16) & 0xFF,
        (int >>> 8) & 0xFF,
        int & 0xFF
    ].join('.');
}
function intToHex(int) {
    return [
        ((int >>> 24) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        ((int >>> 16) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        ((int >>> 8) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
        (int & 0xFF).toString(16).toUpperCase().padStart(2, '0')
    ].join('.');
}
function ipToBinary(ip) {
    return ip.split('.').map(part => parseInt(part).toString(2).padStart(8, '0')).join('.');
}
function isValidIp(ip) {
    const parts = ip.split('.');
    if (parts.length !== 4) return false;
    return parts.every(part => {
        const num = Number(part);
        return num >= 0 && num <= 255 && part === num.toString();
    });
}
function getNetworkClass(firstOctet) {
    if (firstOctet >= 1 && firstOctet <= 126) return 'A';
    if (firstOctet >= 128 && firstOctet <= 191) return 'B';
    if (firstOctet >= 192 && firstOctet <= 223) return 'C';
    if (firstOctet >= 224 && firstOctet <= 239) return 'D (multicast)';
    if (firstOctet >= 240 && firstOctet <= 255) return 'E (reserved)';
    return 'unknown';
}
function isPrivateIp(ip) {
    const parts = ip.split('.').map(Number);
    if (parts[0] === 10) return true;
    if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
    if (parts[0] === 192 && parts[1] === 168) return true;
    return false;
}

/* --- IPv6 helpers --- */
/* Expand IPv6 shorthand :: to full 8-group representation */
function expandIPv6(address) {
    if (!address.includes('::')) {
        // normalize groups to 4 hex digits
        return address.split(':').map(g => g.padStart(4, '0')).join(':');
    }
    const [left, right] = address.split('::');
    const leftGroups = left ? left.split(':').filter(Boolean) : [];
    const rightGroups = right ? right.split(':').filter(Boolean) : [];
    const missing = 8 - (leftGroups.length + rightGroups.length);
    const fill = Array(missing).fill('0');
    const full = [...leftGroups, ...fill, ...rightGroups].map(g => g.padStart(4, '0')).join(':');
    return full;
}

/* Compress IPv6 (simple longest-run compression) */
function compressIPv6(expanded) {
    // input expected as 8 groups with leading zeros possibly present
    const groups = expanded.split(':').map(g => g.replace(/^0+/, '') || '0');
    let bestStart = -1, bestLen = 0;
    for (let i = 0; i < groups.length;) {
        if (groups[i] === '0') {
            let j = i;
            while (j < groups.length && groups[j] === '0') j++;
            const len = j - i;
            if (len > bestLen) { bestLen = len; bestStart = i; }
            i = j;
        } else i++;
    }
    if (bestLen <= 1) return groups.join(':');
    const left = groups.slice(0, bestStart);
    const right = groups.slice(bestStart + bestLen);
    const out = [...left, '', ...right].join(':');
    // ensure :: is present and no accidental leading/trailing single colon
    return out.replace(/(^:)|(:$)/g, '').replace(':::', '::') || '::';
}

/* Convert IPv6 string to BigInt and back */
function ipv6ToBigInt(addr) {
    const expanded = expandIPv6(addr);
    const parts = expanded.split(':');
    let acc = 0n;
    for (const p of parts) {
        acc = (acc << 16n) + BigInt(parseInt(p, 16));
    }
    return acc;
}
function bigIntToIPv6(num) {
    const parts = [];
    let n = BigInt(num);
    for (let i = 0; i < 8; i++) {
        parts.unshift((n & 0xFFFFn).toString(16));
        n >>= 16n;
    }
    const expanded = parts.map(p => p.padStart(4, '0')).join(':');
    return compressIPv6(expanded);
}
function isValidIPv6(ip) {
    // permissive check for typical forms, including ::
    if (typeof ip !== 'string') return false;
    // Reject obvious invalid characters
    if (!/^[0-9A-Fa-f:.]+$/.test(ip)) return false;
    // Count groups and colons roughly, then try expand
    try {
        const expanded = expandIPv6(ip);
        const parts = expanded.split(':');
        return parts.length === 8 && parts.every(p => /^[0-9a-fA-F]{4}$/.test(p));
    } catch {
        return false;
    }
}
function isPrivateIPv6(ip) {
    // Unique local addresses: fc00::/7 (fc00::/7 or fd00::/8 heuristics)
    return ip.toLowerCase().startsWith('fc') || ip.toLowerCase().startsWith('fd');
}

/* --- Clipboard helper (used by result buttons) --- */
function copyToClipboard(text) {
    navigator.clipboard.writeText(String(text)).then(() => {
        showToast('copied to clipboard');
    }).catch(err => {
        showToast('failed to copy');
        console.warn('clipboard write failed', err);
    });
}

/* --- Toast helper --- */
function showToast(message) {
    const toast = document.getElementById('toast');
    if (!toast) return;
    toast.textContent = message;
    toast.classList.add('show');
    setTimeout(() => { toast.classList.remove('show'); }, 2000);
}

/* ---------------------------
   display helpers (kept from original)
   --------------------------- */
function createResultBox(label, value) {
    let html = '<div class="result-box">';
    html += '<div class="result-box-label">' + label + '</div>';
    html += '<div class="result-box-value">';
    html += '<span>' + value + '</span>';
    html += '<button class="copy-btn" onclick="copyToClipboard(\'' + String(value).replace(/'/g, \"\\\\'\") + '\')" title="copy to clipboard">';
    html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
    html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
    html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
    html += '</svg></button>';
    html += '</div></div>';
    return html;
}
function createResultItem(label, value, showCopy = true) {
    let html = '<div class="result-item">';
    html += '<span class="result-label">' + label + '</span>';
    html += '<span class="result-value">' + value;
    if (showCopy) {
        html += '<button class="copy-btn" onclick="copyToClipboard(\'' + String(value).replace(/'/g, \"\\\\'\") + '\')" title="copy to clipboard">';
        html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
        html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
        html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
        html += '</svg></button>';
    }
    html += '</span></div>';
    return html;
}
function showSubnetError(message) {
    const errorDiv = document.getElementById('subnetError');
    if (errorDiv) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
}

/* ---------------------------
   Subnet calculator (IPv4 + IPv6)
   --------------------------- */

function calcSubnet() {
    try {
        const inputRaw = document.getElementById('ipAddress').value.trim();
        const maskSelect = document.getElementById('subnetMask').value;
        const errorDiv = document.getElementById('subnetError');
        const resultsDiv = document.getElementById('subnetResults');

        // hide previous
        if (errorDiv) errorDiv.style.display = 'none';
        if (resultsDiv) resultsDiv.style.display = 'none';

        if (!inputRaw) {
            showSubnetError('please enter an IP address or CIDR.');
            return;
        }

        let ip, prefix;
        if (inputRaw.includes('/')) {
            [ip, prefix] = inputRaw.split('/');
            prefix = parseInt(prefix, 10);
        } else {
            ip = inputRaw;
            prefix = maskSelect ? parseInt(maskSelect, 10) : NaN;
        }

        const isV6 = ip.includes(':');

        if (isV6) {
            // IPv6 path
            if (!isValidIPv6(ip)) {
                showSubnetError('invalid IPv6 address');
                return;
            }
            if (isNaN(prefix) || prefix < 0 || prefix > 128) {
                showSubnetError('invalid IPv6 prefix (0-128)');
                return;
            }

            // compute
            const ipBig = ipv6ToBigInt(ip);
            const hostBits = 128 - prefix;
            const maskBig = (hostBits === 0) ? 0n : ((1n << BigInt(hostBits)) - 1n);
            const networkBig = ipBig & (~maskBig);
            const broadcastBig = networkBig | maskBig;
            const totalAddrs = (hostBits === 0) ? 1n : (1n << BigInt(hostBits));

            // prepare display values
            const networkStr = bigIntToIPv6(networkBig);
            const broadcastStr = bigIntToIPv6(broadcastBig);
            const firstUsable = networkStr; // For IPv6, usable definition is interface-specific; we'll show network and last
            const lastUsable = broadcastStr;

            const displayObj = {
                inputIp: ip,
                inputCidr: `${ip}/${prefix}`,
                inputLong: ipBig.toString(),
                inputHex: null,
                cidr: `${networkStr}/${prefix}`,
                cidrIpRange: `${networkStr} - ${broadcastStr}`,
                cidrLongRange: `${networkBig.toString()} - ${broadcastBig.toString()}`,
                cidrHexRange: null,
                ipsInRange: totalAddrs.toString(),
                maskBits: prefix,
                subnetMask: null,
                hexSubnetMask: null,
                networkAddress: networkStr,
                broadcastAddress: broadcastStr,
                wildcardMask: null,
                firstUsable: firstUsable,
                lastUsable: lastUsable,
                usableHosts: totalAddrs.toString(),
                ipClass: 'IPv6',
                isPrivate: isPrivateIPv6(ip),
                networkBinary: '(not shown for IPv6)',
                maskBinary: '(not shown for IPv6)'
            };

            // render
            displaySubnetResults(displayObj);
            if (document.getElementById('copySubnetBtnContainer')) document.getElementById('copySubnetBtnContainer').style.display = 'block';
            return;
        }

        /* --- IPv4 path (existing logic) --- */
        if (!isValidIp(ip)) {
            showSubnetError('invalid IP address');
            return;
        }
        if (isNaN(prefix) || prefix < 0 || prefix > 32) {
            showSubnetError('invalid CIDR prefix (must be between 0 and 32)');
            return;
        }

        const ipInt = ipToInt(ip);
        const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
        const networkInt = (ipInt & maskInt) >>> 0;
        const broadcastInt = (networkInt | ~maskInt) >>> 0;

        const totalHosts = Math.pow(2, 32 - prefix);
        const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);

        const networkIp = intToIp(networkInt);
        const broadcastIp = intToIp(broadcastInt);
        const subnetMask = intToIp(maskInt);
        const wildcardMask = intToIp((~maskInt) >>> 0);

        const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
        const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));

        const ipClass = getNetworkClass(parseInt(ip.split('.')[0], 10));
        const isPrivate = isPrivateIp(networkIp);

        const inputHex = intToHex(ipInt);
        const networkHex = intToHex(networkInt);
        const broadcastHex = intToHex(broadcastInt);
        const maskHex = intToHex(maskInt);

        const displayObjV4 = {
            inputIp: ip,
            inputCidr: networkIp + '/' + prefix,
            inputLong: ipInt >>> 0,
            inputHex: inputHex,
            cidr: networkIp + '/' + prefix,
            cidrIpRange: networkIp + ' - ' + broadcastIp,
            cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
            cidrHexRange: networkHex + ' - ' + broadcastHex,
            ipsInRange: totalHosts,
            maskBits: prefix,
            subnetMask: subnetMask,
            hexSubnetMask: maskHex,
            networkAddress: networkIp,
            broadcastAddress: broadcastIp,
            wildcardMask: wildcardMask,
            firstUsable: firstUsableIp,
            lastUsable: lastUsableIp,
            usableHosts: usableHosts,
            ipClass: ipClass,
            isPrivate: isPrivate,
            networkBinary: ipToBinary(networkIp),
            maskBinary: ipToBinary(subnetMask)
        };

        displaySubnetResults(displayObjV4);
        if (document.getElementById('copySubnetBtnContainer')) document.getElementById('copySubnetBtnContainer').style.display = 'block';

    } catch (err) {
        console.error('calcSubnet error', err);
        showSubnetError('An unexpected error occurred. See console for details.');
    }
}

/* ---------------------------
   displaySubnetResults (unchanged, but safe guards added)
   --------------------------- */
function displaySubnetResults(data) {
    const resultsDiv = document.getElementById('subnetResults');
    if (!resultsDiv) return;

    // Build HTML but guard against undefined
    const safe = v => (v === null || v === undefined) ? 'n/a' : String(v);

    let html = '<div class="result-grid">';
    html += createResultBox('input', safe(data.inputCidr || data.inputIp || ''));
    html += createResultBox('input ip', safe(data.inputIp));
    html += createResultBox('input long', safe(data.inputLong));
    html += createResultBox('input hex', safe(data.inputHex));
    html += '</div><div class="result-grid">';
    html += createResultBox('cidr', safe(data.cidr));
    html += createResultBox('cidr ip range', safe(data.cidrIpRange));
    html += createResultBox('cidr long range', safe(data.cidrLongRange));
    html += createResultBox('cidr hex range', safe(data.cidrHexRange));
    html += '</div><div class="result-grid">';
    html += createResultBox('ips in range', safe(data.ipsInRange));
    html += createResultBox('mask bits', safe(data.maskBits));
    html += createResultBox('subnet mask', safe(data.subnetMask));
    html += createResultBox('hex subnet mask', safe(data.hexSubnetMask));
    html += '</div>';

    html += '<div class="result-section">';
    html += '<h3>network information</h3>';
    html += createResultItem('network address', safe(data.networkAddress));
    html += createResultItem('broadcast address', safe(data.broadcastAddress));
    html += createResultItem('wildcard mask', safe(data.wildcardMask));
    html += '</div>';

    html += '<div class="result-section">';
    html += '<h3>usable ip range</h3>';
    html += createResultItem('first usable ip', safe(data.firstUsable));
    html += createResultItem('last usable ip', safe(data.lastUsable));
    html += createResultItem('usable ip addresses', safe(data.usableHosts), false);
    html += '</div>';

    html += '<div class="result-section">';
    html += '<h3>additional information</h3>';
    html += createResultItem('ip class', safe(data.ipClass), false);
    html += createResultItem('ip type', (data.isPrivate ? 'private' : 'public'), false);
    html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
    html += '<span class="result-label">binary subnet mask</span>';
    html += '<span class="subnet-binary">' + safe(data.maskBinary) + '</span>';
    html += '</div>';
    html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
    html += '<span class="result-label">network address (binary)</span>';
    html += '<span class="subnet-binary">' + safe(data.networkBinary) + '</span>';
    html += '</div>';
    html += '</div>';

    resultsDiv.innerHTML = html;
    resultsDiv.style.display = 'block';
}

/* ---------------------------
   Copy All Results / Download helpers
   --------------------------- */
function generateSubnetOutputText() {
    const resultsDiv = document.getElementById('subnetResults');
    if (!resultsDiv || resultsDiv.style.display === 'none') return null;

    let output = '';
    const now = new Date();
    output += `Subnet Calculation Results\nGenerated on: ${now.toLocaleString()}\n\n`;

    // find first CIDR-ish item for header
    const cidrItem = [...resultsDiv.querySelectorAll('.result-box, .result-item')]
        .find(el => el.innerText.includes('/') && el.innerText.match(/[\dA-Fa-f:.]+\/\d+/));
    if (cidrItem) {
        const cidrText = cidrItem.innerText.split(':')[1]?.trim() || cidrItem.innerText.trim();
        output += `Input: ${cidrText}\n\n`;
    }

    const sections = resultsDiv.querySelectorAll('.result-section, .result-grid');
    sections.forEach(section => {
        const header = section.querySelector('h3');
        if (header) {
            const title = header.innerText.trim().toUpperCase();
            output += `${title}\n${'='.repeat(title.length)}\n`;
        }
        const items = section.querySelectorAll('.result-item, .result-box');
        items.forEach(item => {
            const label = item.querySelector('.result-label, .result-box-label')?.innerText?.trim() || '';
            const value = item.querySelector('.result-value, .result-box-value span')?.innerText?.trim() || '';
            if (label && value) output += `${label}: ${value}\n`;
        });
        output += '\n';
    });

    // uri decode guard
    if (/%[0-9A-F]{2}/i.test(output)) {
        try { output = decodeURIComponent(output); } catch (e) { /* ignore invalid */ }
    }
    return output.trim() + '\n';
}

function copyAllSubnetResults() {
    const text = generateSubnetOutputText();
    if (!text) { alert('No subnet results to copy.'); return; }
    navigator.clipboard.writeText(text).then(() => showToast('All subnet results copied to clipboard.'))
      .catch(err => { console.error('copy failed', err); showToast('Unable to copy results.'); });
}

function downloadSubnetResults() {
    const text = generateSubnetOutputText();
    if (!text) { alert('No subnet results to download.'); return; }
    const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    a.href = url;
    a.download = `subnet-results-${ts}.txt`;
    a.click();
    URL.revokeObjectURL(url);
    showToast('Subnet results downloaded as text file.');
}

/* ---------------------------
   CIDR calculator (kept intact from original)
   --------------------------- */
function calcCIDR() {
  const startIp = document.getElementById('startIp').value.trim();
  const endIp = document.getElementById('endIp').value.trim();
  const errorDiv = document.getElementById('cidrError');
  const resultsDiv = document.getElementById('cidrResults');
  const outputDiv = document.getElementById('cidrOutput');

  if (errorDiv) errorDiv.style.display = 'none';
  if (resultsDiv) resultsDiv.style.display = 'none';

  if (!validateIP(startIp) || !validateIP(endIp)) {
    showCIDRError('Please enter valid IPv4 addresses.');
    return;
  }

  const start = ipToLong(startIp);
  const end = ipToLong(endIp);

  if (end < start) {
    showCIDRError('End IP must be greater than or equal to Start IP.');
    return;
  }

  const blocks = calculateCIDRBlocks(start, end);

  const infoSection = document.getElementById('cidrInfoSection');
  const infoText = document.getElementById('cidrInfoText');

  infoText.innerHTML = blocks.join('<br>');
  infoSection.style.display = 'block';

  resultsDiv.style.display = 'block';
}

function calculateCIDRBlocks(start, end) {
  const result = [];
  while (end >= start) {
    let maxSize = 32;
    while (maxSize > 0) {
      const mask = 2 ** (32 - maxSize);
      if ((start & (mask - 1)) !== 0) break;
      maxSize--;
    }
    const remaining = end - start + 1;
    while (2 ** (32 - maxSize) > remaining) maxSize++;
    result.push(longToIP(start) + '/' + maxSize);
    start += 2 ** (32 - maxSize);
  }
  return result;
}
function validateIP(ip) {
  const parts = ip.split('.');
  if (parts.length !== 4) return false;
  return parts.every(p => p >= 0 && p <= 255 && /^\d+$/.test(p));
}
function ipToLong(ip) {
  return ip.split('.').reduce((acc, oct) => (acc << 8) + parseInt(oct), 0) >>> 0;
}
function longToIP(long) {
  return [
    (long >>> 24) & 255,
    (long >>> 16) & 255,
    (long >>> 8) & 255,
    long & 255
  ].join('.');
}
function showCIDRError(message) {
  const errorDiv = document.getElementById('cidrError');
  if (errorDiv) { errorDiv.textContent = message; errorDiv.style.display = 'block'; }
}
function clearCIDR() {
  document.getElementById('startIp').value = '';
  document.getElementById('endIp').value = '';
  const er = document.getElementById('cidrError'); if (er) er.style.display = 'none';
  const res = document.getElementById('cidrResults'); if (res) res.style.display = 'none';
}

/* ---------------------------
   Finish: attach Enter key listeners (same as original)
   --------------------------- */
document.getElementById('ipAddress').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') calcSubnet();
});
document.getElementById('startIp').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') calcCIDR();
});
document.getElementById('endIp').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') calcCIDR();
});
</script>

    
</body>
</html>
