<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIDR & Subnet Calculator - Chomp</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f5f5f5;
            color: #434343;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #434343;
            color: white;
            padding: 1.5rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 500;
        }

        .header .subtitle {
            font-size: 0.95rem;
            margin-top: 0.3rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            margin: 2rem auto;
            padding: 0 1.5rem;
            flex: 1;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }

        .card h2 {
            color: #666666;
            font-size: 1.3rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #666666;
            font-weight: 400;
        }

        .input-row {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        input[type="text"] {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        select {
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
            min-width: 120px;
        }

        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #fe0032;
        }

        .btn {
            background-color: #fe0032;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #cc0028;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .results {
            margin-top: 2rem;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .result-box {
            background-color: #f9f9f9;
            padding: 1.25rem;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .result-box-label {
            color: #666666;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .result-box-value {
            color: #434343;
            font-size: 1.1rem;
            font-weight: 500;
            font-family: monospace;
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: space-between;
        }

        .result-section {
            margin-bottom: 2rem;
        }

        .result-section:last-child {
            margin-bottom: 0;
        }

        .result-section h3 {
            color: #fe0032;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #eee;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            color: #666666;
            font-weight: 400;
        }

        .result-value {
            font-weight: 500;
            color: #434343;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: monospace;
        }

        .copy-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: #666666;
            transition: color 0.2s;
            flex-shrink: 0;
        }

        .copy-btn:hover {
            color: #fe0032;
        }

        .error {
            color: #fe0032;
            padding: 0.75rem;
            background-color: #fff0f0;
            border-radius: 4px;
            margin-top: 1rem;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background-color: #434343;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(1rem);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-section {
            margin-top: 2rem;
            color: #666666;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .info-section h3 {
            color: #434343;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
        }

        .subnet-binary {
            font-family: monospace;
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }

        .divider {
            height: 1px;
            background-color: #e0e0e0;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .input-row {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            select {
                width: 100%;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CIDR & Subnet Calculator</h1>
        <div class="subtitle">Calculate subnet information and convert IP ranges to CIDR notation</div>
    </div>

    <div class="container">
        <!-- Subnet Calculator -->
        <div class="card">
            <h2>Subnet Calculator</h2>
            <div class="input-group">
                <label for="ipAddress">IP Address / CIDR</label>
                <div class="input-row">
                    <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.0/24 or 192.168.1.0">
                    <select id="subnetMask">
                        <option value="">Select Mask (optional)</option>
                        <option value="32">/32 - 255.255.255.255</option>
                        <option value="31">/31 - 255.255.255.254</option>
                        <option value="30">/30 - 255.255.255.252</option>
                        <option value="29">/29 - 255.255.255.248</option>
                        <option value="28">/28 - 255.255.255.240</option>
                        <option value="27">/27 - 255.255.255.224</option>
                        <option value="26">/26 - 255.255.255.192</option>
                        <option value="25">/25 - 255.255.255.128</option>
                        <option value="24">/24 - 255.255.255.0</option>
                        <option value="23">/23 - 255.255.254.0</option>
                        <option value="22">/22 - 255.255.252.0</option>
                        <option value="21">/21 - 255.255.248.0</option>
                        <option value="20">/20 - 255.255.240.0</option>
                        <option value="19">/19 - 255.255.224.0</option>
                        <option value="18">/18 - 255.255.192.0</option>
                        <option value="17">/17 - 255.255.128.0</option>
                        <option value="16">/16 - 255.255.0.0</option>
                        <option value="15">/15 - 255.254.0.0</option>
                        <option value="14">/14 - 255.252.0.0</option>
                        <option value="13">/13 - 255.248.0.0</option>
                        <option value="12">/12 - 255.240.0.0</option>
                        <option value="11">/11 - 255.224.0.0</option>
                        <option value="10">/10 - 255.192.0.0</option>
                        <option value="9">/9 - 255.128.0.0</option>
                        <option value="8">/8 - 255.0.0.0</option>
                    </select>
                    <button class="btn" onclick="calculateSubnet()">Calculate</button>
                </div>
            </div>

            <div id="subnetError" class="error" style="display: none;"></div>
            <div id="subnetResults" class="results" style="display: none;"></div>
        </div>

        <div class="divider"></div>

        <!-- CIDR Calculator -->
        <div class="card">
            <h2>CIDR Calculator</h2>
            <div class="input-group">
                <label for="startIp">Starting IP Address</label>
                <input type="text" id="startIp" placeholder="e.g., 192.168.1.0">
            </div>
            <div class="input-group">
                <label for="endIp">Ending IP Address</label>
                <div class="input-row">
                    <input type="text" id="endIp" placeholder="e.g., 192.168.1.255">
                    <button class="btn" onclick="calculateCIDR()">Calculate</button>
                </div>
            </div>

            <div id="cidrError" class="error" style="display: none;"></div>
            <div id="cidrResults" class="results" style="display: none;"></div>
        </div>

        <div class="card">
            <div class="info-section">
                <h3>About These Calculators</h3>
                <p><strong>Subnet Calculator:</strong> Takes a network address in CIDR notation (like 192.168.1.0/24) and calculates important network information including the network address, broadcast address, subnet mask, and the range of usable IP addresses. The prefix length determines how many IP addresses are in the subnet.</p>
                <p style="margin-top: 1rem;"><strong>CIDR Calculator:</strong> Converts IP address ranges to CIDR notation. CIDR (Classless Inter-Domain Routing) is a compact method for specifying IP address ranges. It consists of an IP address followed by a slash and a number (the prefix length), such as 192.168.1.0/24.</p>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        function ipToInt(ip) {
            const parts = ip.split('.').map(Number);
            return (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];
        }

        function intToIp(int) {
            return [
                (int >>> 24) & 0xFF,
                (int >>> 16) & 0xFF,
                (int >>> 8) & 0xFF,
                int & 0xFF
            ].join('.');
        }

        function intToHex(int) {
            return [
                ((int >>> 24) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 16) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                ((int >>> 8) & 0xFF).toString(16).toUpperCase().padStart(2, '0'),
                (int & 0xFF).toString(16).toUpperCase().padStart(2, '0')
            ].join('.');
        }

        function ipToBinary(ip) {
            const parts = ip.split('.');
            return parts.map(part => {
                return parseInt(part).toString(2).padStart(8, '0');
            }).join('.');
        }

        function isValidIp(ip) {
            const parts = ip.split('.');
            if (parts.length !== 4) return false;
            return parts.every(part => {
                const num = Number(part);
                return num >= 0 && num <= 255 && part === num.toString();
            });
        }

        function prefixToMask(prefix) {
            const mask = (0xFFFFFFFF << (32 - prefix)) >>> 0;
            return intToIp(mask);
        }

        function getNetworkClass(firstOctet) {
            if (firstOctet >= 1 && firstOctet <= 126) return 'A';
            if (firstOctet >= 128 && firstOctet <= 191) return 'B';
            if (firstOctet >= 192 && firstOctet <= 223) return 'C';
            if (firstOctet >= 224 && firstOctet <= 239) return 'D (Multicast)';
            if (firstOctet >= 240 && firstOctet <= 255) return 'E (Reserved)';
            return 'Unknown';
        }

        function isPrivateIp(ip) {
            const parts = ip.split('.').map(Number);
            if (parts[0] === 10) return true;
            if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
            if (parts[0] === 192 && parts[1] === 168) return true;
            return false;
        }

        // SUBNET CALCULATOR
        function calculateSubnet() {
            const input = document.getElementById('ipAddress').value.trim();
            const maskSelect = document.getElementById('subnetMask').value;
            const errorDiv = document.getElementById('subnetError');
            const resultsDiv = document.getElementById('subnetResults');

            errorDiv.style.display = 'none';
            resultsDiv.style.display = 'none';

            // Parse input
            let ip, prefix;
            if (input.includes('/')) {
                const parts = input.split('/');
                ip = parts[0];
                prefix = parseInt(parts[1]);
            } else {
                ip = input;
                if (maskSelect) {
                    prefix = parseInt(maskSelect);
                } else {
                    showError('subnetError', 'Please provide a CIDR prefix (e.g., /24) or select a subnet mask');
                    return;
                }
            }

            // Validate
            if (!isValidIp(ip)) {
                showError('subnetError', 'Invalid IP address');
                return;
            }

            if (isNaN(prefix) || prefix < 0 || prefix > 32) {
                showError('subnetError', 'Invalid CIDR prefix (must be between 0 and 32)');
                return;
            }

            // Calculate subnet information
            const ipInt = ipToInt(ip);
            const maskInt = (0xFFFFFFFF << (32 - prefix)) >>> 0;
            const networkInt = (ipInt & maskInt) >>> 0;
            const broadcastInt = (networkInt | ~maskInt) >>> 0;
            const wildcardInt = ~maskInt >>> 0;
            
            const totalHosts = Math.pow(2, 32 - prefix);
            const usableHosts = prefix === 32 ? 1 : (prefix === 31 ? 2 : totalHosts - 2);
            
            const networkIp = intToIp(networkInt);
            const broadcastIp = intToIp(broadcastInt);
            const subnetMask = intToIp(maskInt);
            const wildcardMask = intToIp(wildcardInt);
            
            const firstUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? networkIp : intToIp(networkInt + 1));
            const lastUsableIp = prefix === 32 ? networkIp : (prefix === 31 ? broadcastIp : intToIp(broadcastInt - 1));
            
            const ipClass = getNetworkClass(parseInt(ip.split('.')[0]));
            const isPrivate = isPrivateIp(networkIp);

            // Hex conversions
            const inputHex = intToHex(ipInt);
            const networkHex = intToHex(networkInt);
            const broadcastHex = intToHex(broadcastInt);
            const maskHex = intToHex(maskInt);

            displaySubnetResults({
                inputIp: ip,
                inputCidr: networkIp + '/' + prefix,
                inputLong: ipInt >>> 0,
                inputHex: inputHex,
                cidr: networkIp + '/' + prefix,
                cidrIpRange: networkIp + ' - ' + broadcastIp,
                cidrLongRange: (networkInt >>> 0) + ' - ' + (broadcastInt >>> 0),
                cidrHexRange: networkHex + ' - ' + broadcastHex,
                ipsInRange: totalHosts,
                maskBits: prefix,
                subnetMask: subnetMask,
                hexSubnetMask: maskHex,
                networkAddress: networkIp,
                broadcastAddress: broadcastIp,
                wildcardMask: wildcardMask,
                firstUsable: firstUsableIp,
                lastUsable: lastUsableIp,
                usableHosts: usableHosts,
                ipClass: ipClass,
                isPrivate: isPrivate,
                networkBinary: ipToBinary(networkIp),
                maskBinary: ipToBinary(subnetMask)
            });
        }

        function displaySubnetResults(data) {
            const resultsDiv = document.getElementById('subnetResults');
            
            let html = '<div class="result-grid">';
            
            // Top row - Input information
            html += createResultBox('Input', data.inputCidr);
            html += createResultBox('Input IP', data.inputIp);
            html += createResultBox('Input Long', data.inputLong);
            html += createResultBox('Input Hex', data.inputHex);
            
            html += '</div><div class="result-grid">';
            
            // Second row - CIDR information
            html += createResultBox('CIDR', data.cidr);
            html += createResultBox('CIDR IP Range', data.cidrIpRange);
            html += createResultBox('CIDR Long Range', data.cidrLongRange);
            html += createResultBox('CIDR Hex Range', data.cidrHexRange);
            
            html += '</div><div class="result-grid">';
            
            // Third row - Mask and range information
            html += createResultBox('IPs in Range', data.ipsInRange.toLocaleString());
            html += createResultBox('Mask Bits', data.maskBits);
            html += createResultBox('Subnet Mask', data.subnetMask);
            html += createResultBox('Hex Subnet Mask', data.hexSubnetMask);
            
            html += '</div>';

            // Additional details
            html += '<div class="result-section">';
            html += '<h3>Network Information</h3>';
            html += createResultItem('Network Address', data.networkAddress);
            html += createResultItem('Broadcast Address', data.broadcastAddress);
            html += createResultItem('Wildcard Mask', data.wildcardMask);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>Usable IP Range</h3>';
            html += createResultItem('First Usable IP', data.firstUsable);
            html += createResultItem('Last Usable IP', data.lastUsable);
            html += createResultItem('Usable IP Addresses', data.usableHosts.toLocaleString(), false);
            html += '</div>';

            html += '<div class="result-section">';
            html += '<h3>Additional Information</h3>';
            html += createResultItem('IP Class', data.ipClass, false);
            html += createResultItem('IP Type', data.isPrivate ? 'Private' : 'Public', false);
            
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">Binary Subnet Mask</span>';
            html += '<span class="subnet-binary">' + data.maskBinary + '</span>';
            html += '</div>';
            
            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start;">';
            html += '<span class="result-label">Network Address (Binary)</span>';
            html += '<span class="subnet-binary">' + data.networkBinary + '</span>';
            html += '</div>';
            
            html += '</div>';

            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function createResultBox(label, value) {
            let html = '<div class="result-box">';
            html += '<div class="result-box-label">' + label + '</div>';
            html += '<div class="result-box-value">';
            html += '<span>' + value + '</span>';
            html += '<button class="copy-btn" onclick="copyToClipboard(\'' + value.replace(/'/g, "\\'") + '\')" title="Copy to clipboard">';
            html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
            html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
            html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
            html += '</svg></button>';
            html += '</div></div>';
            return html;
        }

        // CIDR CALCULATOR
        function calculateCIDR() {
            const startIp = document.getElementById('startIp').value.trim();
            const endIp = document.getElementById('endIp').value.trim();
            const errorDiv = document.getElementById('cidrError');
            const resultsDiv = document.getElementById('cidrResults');

            errorDiv.style.display = 'none';
            resultsDiv.style.display = 'none';

            // Validate IPs
            if (!isValidIp(startIp)) {
                showError('cidrError', 'Invalid starting IP address');
                return;
            }
            if (!isValidIp(endIp)) {
                showError('cidrError', 'Invalid ending IP address');
                return;
            }

            const startInt = ipToInt(startIp);
            const endInt = ipToInt(endIp);

            if (startInt > endInt) {
                showError('cidrError', 'Starting IP must be less than or equal to ending IP');
                return;
            }

            // Calculate CIDR blocks
            const cidrBlocks = calculateCIDRBlocks(startInt, endInt);

            if (cidrBlocks.length === 0) {
                showError('cidrError', 'Unable to calculate CIDR notation for this range');
                return;
            }

            displayCIDRResults(cidrBlocks, endInt - startInt + 1);
        }

        function calculateCIDRBlocks(start, end) {
            const blocks = [];
            let current = start;

            while (current <= end) {
                let maxSize = 32;
                
                // Find the largest block that starts at current and doesn't exceed end
                for (let size = 0; size <= 32; size++) {
                    const blockSize = Math.pow(2, 32 - size);
                    const blockEnd = current + blockSize - 1;
                    
                    // Check if this block fits
                    if (current % blockSize === 0 && blockEnd <= end) {
                        maxSize = size;
                    } else {
                        break;
                    }
                }

                const blockSize = Math.pow(2, 32 - maxSize);
                blocks.push({
                    network: intToIp(current),
                    prefix: maxSize,
                    size: blockSize
                });

                current += blockSize;
            }

            return blocks;
        }

        function displayCIDRResults(cidrBlocks, totalIps) {
            const resultsDiv = document.getElementById('cidrResults');
            
            let html = '<div class="result-item">';
            html += '<span class="result-label">Total IP Addresses</span>';
            html += '<span class="result-value">' + totalIps.toLocaleString() + '</span>';
            html += '</div>';

            html += '<div class="result-item">';
            html += '<span class="result-label">Number of CIDR Blocks</span>';
            html += '<span class="result-value">' + cidrBlocks.length + '</span>';
            html += '</div>';

            html += '<div class="result-item" style="flex-direction: column; align-items: flex-start; padding: 1rem 0;">';
            html += '<span class="result-label" style="margin-bottom: 0.75rem;">CIDR Notation</span>';
            
            cidrBlocks.forEach((block, index) => {
                const cidr = block.network + '/' + block.prefix;
                html += '<div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 0.5rem;">';
                html += '<span class="result-value" style="font-family: monospace;">' + cidr + '</span>';
                html += '<button class="copy-btn" onclick="copyToClipboard(\'' + cidr + '\')" title="Copy to clipboard">';
                html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
                html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
                html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
                html += '</svg></button></div>';
            });
            
            html += '</div>';

            resultsDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function createResultItem(label, value, showCopy = true) {
            let html = '<div class="result-item">';
            html += '<span class="result-label">' + label + '</span>';
            html += '<span class="result-value">' + value;
            if (showCopy) {
                html += '<button class="copy-btn" onclick="copyToClipboard(\'' + value + '\')" title="Copy to clipboard">';
                html += '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">';
                html += '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>';
                html += '<path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
                html += '</svg></button>';
            }
            html += '</span></div>';
            return html;
        }

        function showError(elementId, message) {
            const errorDiv = document.getElementById(elementId);
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard');
            }).catch(err => {
                showToast('Failed to copy');
            });
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // Allow Enter key to trigger calculation
        document.getElementById('ipAddress').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calculateSubnet();
        });
        document.getElementById('startIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calculateCIDR();
        });
        document.getElementById('endIp').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') calculateCIDR();
        });
    </script>
</body>
</html>
